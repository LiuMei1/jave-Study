package _11_thread;

public class TicketDemo {

	public static void main(String[] args) {
		
		/**
		 * 131-136
		 * 需求：简单的卖票程序：
		 *   多个窗口同时卖票。
		 *   
		 *   创建线程的第二种方式：实现Runable 接口
		 *   
		 *   步骤：
		 *   1，定义类实现Runnable接口
		 *   2，覆盖Runnable 接口中的run方法。
		 *      将线程要运行的代码存放在该run方法中。
		 *   3， 通过Thread类建立线程对象。
		 *   4，将Runnable 接口的子类对象作为实际参数传递给Thread类的构造函数。
		 *   为什么？
		 *   因为，自定义的run方法所属的对象是runnable接口的子类对象。
		 *   所以要让线程去指定指定对象的run方法。就必须明确该run方法所属对象。
		 *   5，调用Thread 类的start方法开启线程并调用Runnable接口子类的run方法。
		 *   
		 *   实现方式和继承方式有什么区别呢？
		 *   
		 *   实现方法好处：避免了单继承的局限性。
		 *   在定义线程时，建议使用实现方式。
		 *   
		 *   继承Thread：线程代码存放在Thread子类run方法中。
		 *   实现Runnable：线程代码存在接口的子类run方法中。
		 *     
		 *     
		 *     
		 *     通过分析，发现，打印出0，-1，-2等错票。
		 *     
		 *     多线程的运行出现了安全问题。
		 *     
		 *     问题的原因：
		 *           当多条语句在操作同一线程共享数据时，一个线程对多条语句只执行了
		 *           一部分，还没有执行完另一个线程参与进来执行。导致共享数据的错误。
		 *     解决办法：   
		 *           对多条操作共享数据的语句，只能让一个线程都执行完在执行过程中，其
		 *           他线程不可以参与执行  。
		 *           
		 *      Java对于线程的安全问题提供了专业的解决方式。
		 *      就是同步代码块。
		 *           synchronized(对象) {
		 *               需要被同步的代码块
		 *           } 
		 *       对象犹如锁。持有锁的线程可以在同步中执行。
		 *       没有持有锁的线程即使获取CPU的执行权，也进不去，因为没有获得锁。
		 *       
		 *       同步的前提：
		 *       1，必须要有两个或者两个以上的线程。
		 *       2，必须是多个线程使用同一个锁。
		 *       
		 *       必须保证同步中只能有一个线程能运行。
		 *       
		 *       好处： 解决了多线程的安全问题。
		 *       弊端： 多个线程需要判断锁，较为消耗资源（允许范围内）。
		 *      
		 */
		
		Ticket t = new Ticket();
		
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		
		
		t1.start();
		t2.start();
		t3.start(); 
		t4.start();
	}
}
